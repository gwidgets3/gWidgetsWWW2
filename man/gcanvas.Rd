\name{gcanvas}
\alias{gcanvas}
\alias{GCanvas}
\title{Widget containing a canvas element.}
\usage{
  gcanvas(f = NULL, width = 480, height = 400, container =
  NULL, ...)
}
\arguments{
  \item{f}{Optional. A file name containing output
  generated by the \code{canvas} device.}

  \item{width}{width in pixels of component. Sizing in
  \pkg{gWidgetsWWW2} is sometimes necessary as the
  arguments \code{expand} and \code{fill} are not well
  implemented.}

  \item{height}{height in pixels of the component.}

  \item{container}{A parent container. In
  \pkg{gWidgetsWWW2} a parent container is not optional
  (though it can be substituted with the \code{parent}
  argument in some circumstances). The parent specifies the
  widget heirarchy and the \code{...} argument is used to
  pass along arguments to layout the child component in the
  parent container. Typically, these are passed to the
  \code{add} method of the parent container.}

  \item{...}{Used to pass along argument to the parent
  container's \code{add} method and possible other
  arguments to the underlying ference class constructors.}
}
\value{
  an \code{GCanvas} reference class object
}
\description{
  Primarily this is a widget meant to hold a graphic
  produced by the \pkg{canvas} package device direct.  This
  package provides a non-interactive device for creating
  graphic files using JavaScript. This widget allows such
  files to be displayed easily. However, one can also write
  low-level canvas methods to the device if desired.  When
  used with the \pkg{canvas} package, one passes to the
  constructor or the \code{svalue<-} method a function that
  has been used by the \code{canvas} device driver to store
  the JavaScript commands representing the graphic. The
  basic use is in an example below.

  The \code{GCanvas} class is the base class for the
  \code{gcanvas} widget, which provides an HTML5 canvas
  widget for drawing on or for displaying graphics produced
  by the \pkg{canvas} device. The drawing is supported
  through a series of low-level primitives (reference class
  methods): \code{polygon}, \code{lines}, \code{rect},
  \code{circle}. Others are possible.  In addition, there
  are additional handlers: \code{add_handler_clicked},
  \code{add_handler_mouse_motion}, .... These are passed
  back event information through the \code{h} object. The
  method \code{get_event_params} provides the mapping.
}
\details{
  The canvas widget can listen for mouse events, notably
  the click event.  The first argument list for the
  callback passed to \code{addHandlerClicked} has
  additional components \code{x,y} containing the position
  of the click in ndc coordinates (in [0,1] with (0,0)
  being lower left; \code{X,Y} the pixel position of the
  click with (0,0) being the upper left corner; and
  \code{width, height} containing the width and height of
  the canvas widget (also passed in to the constructor, but
  this makes things convenient). Conversion from ndc to
  "user" coordinates is done with \code{grconvertXY}, but
  there is a catch, as one must call this with an active
  device.  The low level canvas command allow one to draw
  on the canvas using the pixel coordinates, which are
  passed back as \code{X} and \code{Y}. The pixel
  coordinates use (0,0) as the upper right. A demo shows
  how the low level commands can be used with the mouse
  motion handlers to create a GUI where an element can be
  dragged around. It isn't as responsive as one would hope,
  as the callback into R from the browser has too much lag.
}
\note{
  In the click handler one gets passed the click coordinate
  in ndc coordinates, as this is the best the JavaScript
  can do, not knowing the device parameters. When R gets
  this back it doesn't have the current device to call
  \code{grconvertX}, say, so one needs to hack in a call to
  the canvas device to reset the parameters. See the demo
  examples. The examples here are more basic.
}
\examples{
w <- gwindow()
gstatusbar("Powered by gWidgetsWWW2 and Rook", cont=w)

width <- height <- 250
f <- tempfile()
canvas(f, width=width, height=height)
hist(rnorm(100))
dev.off()
cnv <- gcanvas(f, container=w, width=width, height=height)
## make a new new graphic
gbutton("refresh", cont=w, handler=function(h,...) {
f <- svalue(cnv)
canvas(f, width=width, height=height)
hist(rnorm(100))
dev.off()
svalue(cnv) <- f
})

## Using canvas for drawing area using lower level canvas methods
w <- gwindow("gcanvas example")
sb <- gstatusbar("Powered by gWidgetsWWW2 and Rack", cont=w)
g <- ggroup(cont=w, horizontal=FALSE)
width <- 500; height <- 500

cnv <- gcanvas(width=width, height=height, cont=g)

started <-FALSE
cnv$add_handler_mouse_down(handler=function(h,...) {
cnv$call_method("beginPath")
cnv$call_method("moveTo", h$X, h$Y)
started <<- TRUE
})


cnv$add_handler_mouse_move(handler=function(h,...) {
if(started) {
cnv$call_method("lineTo", h$X, h$Y)
cnv$call_method("stroke")
}
})

cnv$add_handler_mouse_up(handler=function(h,...) {
started <<- FALSE
})
}

